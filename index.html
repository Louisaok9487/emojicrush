<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Emoji Candy Crush</title>
    <!-- Tailwind CSS CDN -->
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* Custom styles to ensure emojis are centred and board is a grid */
        body {
            font-family: "Inter", sans-serif;
            background-color: #f0f4f8; /* Light blue-grey background */
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            margin: 0;
            overflow: hidden; /* Prevent scrollbars */
        }
        .game-board {
            display: grid;
            border: 4px solid #6b7280; /* Darker grey border for the board */
            border-radius: 1rem; /* Rounded corners for the board */
            background-color: #cbd5e1; /* Lighter grey background for the board cells */
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05); /* Subtle shadow */
        }
        .emoji-cell {
            width: 60px; /* Fixed width for each cell */
            height: 60px; /* Fixed height for each cell */
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 2.5rem; /* Large emoji size */
            cursor: pointer;
            border: 1px solid rgba(255, 255, 255, 0.3); /* Light border for cell separation */
            transition: transform 0.15s ease-in-out, opacity 0.15s ease-in-out, background-color 0.2s ease-in-out;
            user-select: none; /* Prevent text selection on emojis */
            position: relative; /* Needed for transform to work correctly */
        }
        /* Make cells slightly darker on hover for visual feedback */
        .emoji-cell:hover {
            background-color: rgba(0, 0, 0, 0.05);
        }
        /* Style for selected cell */
        .emoji-cell.selected {
            border: 3px solid #f97316; /* Orange border for selected cell */
            box-shadow: 0 0 15px rgba(249, 115, 22, 0.7); /* Glow effect */
            transform: scale(1.05); /* Slightly enlarge selected cell */
            z-index: 10; /* Bring selected cell to front */
        }
        /* Style for clearing animation */
        .emoji-cell.clearing {
            transform: scale(0); /* Shrink to disappear */
            opacity: 0; /* Fade out */
        }
        /* Style for falling animation */
        .emoji-cell.falling {
            transition: transform 0.15s ease-in-out; /* Smooth fall transition, matching new duration */
        }
        /* Combo text animation */
        .combo-text {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 3rem;
            font-weight: bold;
            color: #fff;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5);
            animation: comboPop 1s forwards;
            pointer-events: none; /* Allow clicks to pass through */
            z-index: 20;
        }
        @keyframes comboPop {
            0% { opacity: 0; transform: translate(-50%, -50%) scale(0.5); }
            50% { opacity: 1; transform: translate(-50%, -50%) scale(1.2); }
            100% { opacity: 0; transform: translate(-50%, -100%) scale(0.8); }
        }

        /* Message Box styles */
        .message-box-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.7);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
        }
        .message-box {
            background-color: #fff;
            padding: 2.5rem;
            border-radius: 1.5rem;
            box-shadow: 0 10px 20px rgba(0, 0, 0, 0.2);
            text-align: center;
            max-width: 90%;
            width: 400px;
            transform: scale(0.8);
            opacity: 0;
            animation: popIn 0.3s forwards;
        }
        @keyframes popIn {
            to { transform: scale(1); opacity: 1; }
        }
    </style>
</head>
<body class="bg-gradient-to-br from-purple-400 to-pink-500">
    <div class="flex flex-col items-center p-6 bg-white rounded-2xl shadow-xl">
        <h1 class="text-5xl font-extrabold mb-6 text-transparent bg-clip-text bg-gradient-to-r from-yellow-500 to-orange-600 drop-shadow-lg">
            Emoji Crush!
        </h1>
        <div class="flex justify-between w-full max-w-sm mb-4 text-2xl font-semibold text-gray-700">
            <span>Level: <span id="level">1</span></span>
            <span>Score: <span id="score">0</span> / <span id="targetScore">0</span></span>
            <span>Moves: <span id="moves">0</span></span>
        </div>
        <div id="gameBoard" class="game-board">
            <!-- Emoji cells will be injected here by JavaScript -->
        </div>
    </div>

    <!-- Message Box for Win/Lose -->
    <div id="messageBoxOverlay" class="message-box-overlay hidden">
        <div class="message-box">
            <h2 id="messageTitle" class="text-4xl font-bold mb-4 text-gray-800"></h2>
            <p id="messageText" class="text-lg text-gray-600 mb-6"></p>
            <button id="messageButton" class="px-6 py-3 bg-blue-500 text-white font-bold rounded-full shadow-lg hover:bg-blue-600 transition-all transform hover:scale-105">
                Play Again
            </button>
        </div>
    </div>

    <script>
        // Define game board dimensions
        const BOARD_ROWS = 8;
        const BOARD_COLS = 8;
        const CELL_SIZE = 60; // px
        const ANIMATION_DURATION = 150; // ms, for swap, clear, fall animations

        // Emojis to be used as "candies"
        const BASE_EMOJIS = ['🍭', '🍬', '🍎', '🍇', '💎', '✨', '💖', '🌟'];

        // New special emoji types
        const STRIPED_EMOJI = '⚡️'; // Clears a row or column
        const WRAPPED_EMOJI = '🎁'; // Clears a 3x3 area
        const COLOR_BOMB_EMOJI = '🌈'; // Clears all of one emoji type

        // Game state variables
        let gameBoard = []; // 2D array to store the current state of the board
        let score = 0;
        let moves = 0;
        let selectedCell = null; // Stores the first clicked cell element
        let isSwapping = false; // Flag to prevent rapid clicks during animation
        let isProcessingBoard = false; // Flag to prevent new swaps during gravity/refill/chain reactions
        let currentLevelIndex = 0; // Start at the first level

        // Level definitions
        const levels = [
            { targetScore: 500, maxMoves: 20 },
            { targetScore: 1200, maxMoves: 25 },
            { targetScore: 2500, maxMoves: 30 }
            // Add more levels as desired
        ];

        // DOM elements
        const gameBoardElement = document.getElementById('gameBoard');
        const scoreElement = document.getElementById('score');
        const movesElement = document.getElementById('moves');
        const levelElement = document.getElementById('level');
        const targetScoreElement = document.getElementById('targetScore');
        const messageBoxOverlay = document.getElementById('messageBoxOverlay');
        const messageTitle = document.getElementById('messageTitle');
        const messageText = document.getElementById('messageText');
        const messageButton = document.getElementById('messageButton');

        // Sound Effects (using Tone.js for more control, but simple Audio objects work too)
        const audioContext = new (window.AudioContext || window.webkitAudioContext)();

        function playSound(frequency, duration, type = 'sine') {
            const oscillator = audioContext.createOscillator();
            const gainNode = audioContext.createGain();

            oscillator.type = type;
            oscillator.frequency.setValueAtTime(frequency, audioContext.currentTime);
            gainNode.gain.setValueAtTime(0.5, audioContext.currentTime); // Volume

            oscillator.connect(gainNode);
            gainNode.connect(audioContext.destination);

            oscillator.start();
            gainNode.gain.exponentialRampToValueAtTime(0.0001, audioContext.currentTime + duration);
            oscillator.stop(audioContext.currentTime + duration);
        }

        /**
         * Returns a random base emoji (not a special emoji).
         * @returns {string} A random emoji character.
         */
        function getRandomBaseEmoji() {
            return BASE_EMOJIS[Math.floor(Math.random() * BASE_EMOJIS.length)];
        }

        /**
         * Retrieves the DOM element for a given row and column.
         * @param {number} r The row index.
         * @param {number} c The column index.
         * @returns {HTMLElement|null} The cell element, or null if not found.
         */
        function getCellElement(r, c) {
            return gameBoardElement.children[r * BOARD_COLS + c];
        }

        /**
         * Updates the visual display of a cell's emoji.
         * @param {number} r The row index.
         * @param {number} c The column index.
         */
        function updateCellDisplay(r, c) {
            const cellElement = getCellElement(r, c);
            if (cellElement) {
                cellElement.textContent = gameBoard[r][c];
            }
        }

        /**
         * Displays a combo text animation.
         * @param {string} text The text to display (e.g., "Nice!", "Awesome!").
         */
        function showComboText(text) {
            const comboTextElement = document.createElement('div');
            comboTextElement.classList.add('combo-text');
            comboTextElement.textContent = text;
            document.body.appendChild(comboTextElement);

            setTimeout(() => {
                comboTextElement.remove();
            }, 1000); // Matches CSS animation duration
        }

        /**
         * Activates the effect of a special emoji.
         * @param {number} r The row of the special emoji.
         * @param {number} c The column of the special emoji.
         * @param {string} type The type of special emoji (STRIPED_EMOJI, WRAPPED_EMOJI, COLOR_BOMB_EMOJI).
         * @param {string|null} swappedWithEmoji The emoji type it was swapped with (for Color Bomb).
         * @returns {Set<string>} A set of coordinates (e.g., "r,c") of cells to be cleared by the special emoji.
         */
        function activateSpecialEmoji(r, c, type, swappedWithEmoji = null) {
            let cellsAffected = new Set();
            console.log(`Activating special emoji at ${r},${c} of type ${type}`);
            playSound(800, 0.15, 'triangle'); // Special match sound

            if (type === STRIPED_EMOJI) {
                // Clear entire row and column
                for (let col = 0; col < BOARD_COLS; col++) cellsAffected.add(`${r},${col}`);
                for (let row = 0; row < BOARD_ROWS; row++) cellsAffected.add(`${row},${c}`);
            } else if (type === WRAPPED_EMOJI) {
                // Clear 3x3 area around the wrapped emoji
                for (let rowOffset = -1; rowOffset <= 1; rowOffset++) {
                    for (let colOffset = -1; colOffset <= 1; colOffset++) {
                        const targetR = r + rowOffset;
                        const targetC = c + colOffset;
                        if (targetR >= 0 && targetR < BOARD_ROWS && targetC >= 0 && targetC < BOARD_COLS) {
                            cellsAffected.add(`${targetR},${targetC}`);
                        }
                    }
                }
            } else if (type === COLOR_BOMB_EMOJI) {
                // Determine which emoji type to clear
                let targetEmojiType = swappedWithEmoji;
                // Ensure targetEmojiType is a valid base emoji, otherwise pick a random one
                if (!targetEmojiType || !BASE_EMOJIS.includes(targetEmojiType)) {
                    targetEmojiType = BASE_EMOJIS[Math.floor(Math.random() * BASE_EMOJIS.length)];
                }

                console.log(`Color bomb clearing all '${targetEmojiType}' emojis.`);
                for (let row = 0; row < BOARD_ROWS; row++) {
                    for (let col = 0; col < BOARD_COLS; col++) {
                        if (gameBoard[row][col] === targetEmojiType) {
                            cellsAffected.add(`${row},${col}`);
                        }
                    }
                }
            }
            return cellsAffected;
        }

        /**
         * Finds all matches (3+, 4+, 5+, L/T shapes) on the board.
         * Prioritizes longer matches and special candy formations.
         * @returns {object} An object containing:
         * - cellsToClear: Set<string> of coordinates (e.g., "r,c") of all matched cells.
         * - specialCreations: Array of {row, col, type} for new special emojis.
         */
        function getMatchesOnBoard() {
            let cellsToClear = new Set();
            let potentialSpecialCreations = new Map(); // Key: "r,c", Value: {type, priority}

            // Helper to add a special creation, prioritizing higher power-ups
            const addSpecialCreation = (r, c, type) => {
                const coordStr = `${r},${c}`;
                const currentPriority = { [COLOR_BOMB_EMOJI]: 3, [WRAPPED_EMOJI]: 2, [STRIPED_EMOJI]: 1 }[type];
                if (!potentialSpecialCreations.has(coordStr) || currentPriority > potentialSpecialCreations.get(coordStr).priority) {
                    potentialSpecialCreations.set(coordStr, { type, priority: currentPriority, row: r, col: c });
                }
            };

            // Create a copy of the board for detection to avoid modifying it during detection
            let tempBoardForDetection = gameBoard.map(row => [...row]);

            // Store all detected lines for L/T shape analysis
            let horizontalLines = [];
            let verticalLines = [];

            // --- Find all horizontal lines (3+ matches) ---
            for (let r = 0; r < BOARD_ROWS; r++) {
                for (let c = 0; c < BOARD_COLS - 2; c++) {
                    const emoji = tempBoardForDetection[r][c];
                    // Use BASE_EMOJIS.includes to correctly identify base emojis
                    if (!emoji || !BASE_EMOJIS.includes(emoji)) continue;

                    if (emoji === tempBoardForDetection[r][c + 1] && emoji === tempBoardForDetection[r][c + 2]) {
                        let currentLine = [];
                        let k = c;
                        while (k < BOARD_COLS && tempBoardForDetection[r][k] === emoji) {
                            currentLine.push({ r, c: k });
                            k++;
                        }
                        horizontalLines.push(currentLine);
                        c = k - 1; // Move cursor past this line
                    }
                }
            }

            // --- Find all vertical lines (3+ matches) ---
            for (let c = 0; c < BOARD_COLS; c++) {
                for (let r = 0; r < BOARD_ROWS - 2; r++) {
                    const emoji = tempBoardForDetection[r][c];
                    // Use BASE_EMOJIS.includes to correctly identify base emojis
                    if (!emoji || !BASE_EMOJIS.includes(emoji)) continue;

                    if (emoji === tempBoardForDetection[r + 1][c] && emoji === tempBoardForDetection[r + 2][c]) {
                        let currentLine = [];
                        let k = r;
                        while (k < BOARD_ROWS && tempBoardForDetection[k][c] === emoji) {
                            currentLine.push({ r: k, c });
                            k++;
                        }
                        verticalLines.push(currentLine);
                        r = k - 1; // Move cursor past this line
                    }
                }
            }

            // --- Populate cellsToClear and identify special candy creations from lines ---
            // Process horizontal lines
            horizontalLines.forEach(line => {
                line.forEach(cell => cellsToClear.add(`${cell.r},${cell.c}`)); // Add all cells in lines to be cleared

                if (line.length >= 5) {
                    addSpecialCreation(line[0].r, line[0].c, COLOR_BOMB_EMOJI);
                } else if (line.length >= 4) {
                    addSpecialCreation(line[0].r, line[0].c, STRIPED_EMOJI);
                }
            });

            // Process vertical lines
            verticalLines.forEach(line => {
                line.forEach(cell => cellsToClear.add(`${cell.r},${cell.c}`)); // Add all cells in lines to be cleared

                if (line.length >= 5) {
                    addSpecialCreation(line[0].r, line[0].c, COLOR_BOMB_EMOJI);
                } else if (line.length >= 4) {
                    addSpecialCreation(line[0].r, line[0].c, STRIPED_EMOJI);
                }
            });

            // --- Detect L/T shapes for Wrapped Emojis ---
            // An L/T shape is formed by the intersection of a horizontal and a vertical line of the same emoji.
            for (let r = 0; r < BOARD_ROWS; r++) {
                for (let c = 0; c < BOARD_COLS; c++) {
                    const currentEmoji = tempBoardForDetection[r][c];
                    // Only check base emojis for L/T formation
                    if (!currentEmoji || !BASE_EMOJIS.includes(currentEmoji)) continue;

                    let isPartOfHorizontalLine = horizontalLines.some(line =>
                        line.some(cell => cell.r === r && cell.c === c) &&
                        line.every(cell => tempBoardForDetection[cell.r][cell.c] === currentEmoji) // Ensure all cells in line are the same emoji
                    );
                    let isPartOfVerticalLine = verticalLines.some(line =>
                        line.some(cell => cell.r === r && cell.c === c) &&
                        line.every(cell => tempBoardForDetection[cell.r][cell.c] === currentEmoji) // Ensure all cells in line are the same emoji
                    );

                    if (isPartOfHorizontalLine && isPartOfVerticalLine) {
                        // This cell is an intersection point, indicating an L or T shape.
                        addSpecialCreation(r, c, WRAPPED_EMOJI);
                    }
                }
            }

            // --- Finalize special creations and adjust cellsToClear ---
            const finalSpecialCreations = Array.from(potentialSpecialCreations.values()).map(item => ({
                row: item.row,
                col: item.col,
                type: item.type
            }));
            console.log("Final special creations:", finalSpecialCreations);

            // Remove the locations of created special candies from cellsToClear
            // This ensures special candies are transformed, not just cleared.
            finalSpecialCreations.forEach(sc => {
                const coordStr = `${sc.row},${sc.col}`;
                if (cellsToClear.has(coordStr)) {
                    cellsToClear.delete(coordStr);
                    console.log(`Removed ${coordStr} from cellsToClear (became special ${sc.type})`);
                }
            });

            console.log("Cells to clear:", [...cellsToClear]);
            return { cellsToClear, specialCreations: finalSpecialCreations };
        }

        /**
         * Checks the entire board for horizontal and vertical matches of 3 or more emojis.
         * Clears the matched emojis and updates the score. Handles special emoji creation.
         * @returns {boolean} True if any matches were found and cleared, or any special emojis were created.
         */
        function checkAndClearMatches() {
            const { cellsToClear, specialCreations } = getMatchesOnBoard();
            let activityOccurred = cellsToClear.size > 0 || specialCreations.length > 0;

            if (activityOccurred) {
                playSound(440, 0.1); // Play match sound

                // Clear matched emojis visually and in gameBoard
                cellsToClear.forEach(coord => {
                    const [r, c] = coord.split(',').map(Number);
                    const cellElement = getCellElement(r, c);

                    if (cellElement) {
                        cellElement.classList.add('clearing');
                        setTimeout(() => {
                            cellElement.textContent = '';
                            cellElement.classList.remove('clearing');
                        }, ANIMATION_DURATION);
                    }
                    gameBoard[r][c] = ''; // Mark as cleared in the gameBoard array
                    score += 10;
                });
                scoreElement.textContent = score;
                console.log('Matches cleared. Score:', score);
            }

            // Create special emojis after clearing
            specialCreations.forEach(creation => {
                const { row, col, type } = creation;
                gameBoard[row][col] = type; // Update gameBoard with special emoji
                const cellElement = getCellElement(row, col);
                if (cellElement) {
                    cellElement.textContent = type; // Display special emoji
                    // Optional: Add a subtle animation for special emoji creation
                }
                console.log(`Special emoji created: ${type} at ${row},${col}`);
            });

            return activityOccurred;
        }

        /**
         * Applies gravity: moves emojis down to fill empty spaces.
         * Emojis fall visually and in the gameBoard array.
         */
        function applyGravity() {
            for (let c = 0; c < BOARD_COLS; c++) {
                let emptySpacesInColumn = 0;
                for (let r = BOARD_ROWS - 1; r >= 0; r--) {
                    if (gameBoard[r][c] === '') {
                        emptySpacesInColumn++;
                    } else if (emptySpacesInColumn > 0) {
                        // Move emoji down by `emptySpacesInColumn` amount
                        const emojiToMove = gameBoard[r][c];
                        gameBoard[r + emptySpacesInColumn][c] = emojiToMove;
                        gameBoard[r][c] = ''; // Clear original position

                        // Visually move the emoji
                        const currentCellElement = getCellElement(r, c);
                        const targetCellElement = getCellElement(r + emptySpacesInColumn, c);

                        if (currentCellElement && targetCellElement) {
                            // Temporarily move the DOM element to the new position
                            // The actual content swap will happen in fillEmptySpaces
                            const tempText = currentCellElement.textContent;
                            currentCellElement.textContent = ''; // Clear original visual
                            targetCellElement.textContent = tempText; // Set new visual

                            // Apply falling animation
                            targetCellElement.style.transform = `translateY(-${emptySpacesInColumn * CELL_SIZE}px)`;
                            targetCellElement.classList.add('falling');
                            setTimeout(() => {
                                targetCellElement.style.transform = ''; // Reset transform
                                targetCellElement.classList.remove('falling');
                            }, ANIMATION_DURATION);
                        }
                    }
                }
            }
            console.log('Gravity applied:', gameBoard);
        }

        /**
         * Fills any remaining empty spaces at the top of the board with new random emojis.
         * Updates both the gameBoard array and the visual representation.
         */
        function fillEmptySpaces() {
            for (let c = 0; c < BOARD_COLS; c++) {
                for (let r = 0; r < BOARD_ROWS; r++) {
                    if (gameBoard[r][c] === '') {
                        const newEmoji = getRandomBaseEmoji(); // Use getRandomBaseEmoji
                        gameBoard[r][c] = newEmoji; // Add new emoji to game state

                        const cellElement = getCellElement(r, c);
                        if (cellElement) {
                            cellElement.textContent = newEmoji; // Visually display new emoji
                            // Optional: Add a "pop-in" animation for new emojis
                        }
                    }
                }
            }
            console.log('Empty spaces filled:', gameBoard);
        }

        /**
         * Reverses the visual and array swap if no match was found after a move.
         * @param {HTMLElement} cell1 The first cell element.
         * @param {HTMLElement} cell2 The second cell element.
         * @returns {Promise<void>} A promise that resolves after the reverse animation.
         */
        async function reverseSwap(cell1, cell2) {
            // Calculate translation values for animation (reversed)
            const row1 = parseInt(cell1.dataset.row);
            const col1 = parseInt(cell1.dataset.col);
            const row2 = parseInt(cell2.dataset.row);
            const col2 = parseInt(cell2.dataset.col);

            const deltaX1 = (col1 - col2) * CELL_SIZE; // Move cell1 back to cell2's original spot
            const deltaY1 = (row1 - row2) * CELL_SIZE;
            const deltaX2 = (col2 - col1) * CELL_SIZE; // Move cell2 back to cell1's original spot
            const deltaY2 = (row1 - row2) * CELL_SIZE;

            // Apply transform for reverse animation
            cell1.style.transform = `translate(${deltaX1}px, ${deltaY1}px)`;
            cell2.style.transform = `translate(${deltaX2}px, ${deltaY2}px)`;

            // Wait for the reverse animation to complete
            return new Promise(resolve => {
                setTimeout(() => {
                    // Visually swap emojis back
                    const tempEmoji = cell1.textContent;
                    cell1.textContent = cell2.textContent;
                    cell2.textContent = tempEmoji;

                    // Reset transform to original position
                    cell1.style.transform = '';
                    cell2.style.transform = '';

                    // Swap emojis in the gameBoard array back
                    const tempGameBoardEmoji = gameBoard[row1][col1];
                    gameBoard[row1][col1] = gameBoard[row2][col2];
                    gameBoard[row2][col2] = tempGameBoardEmoji;

                    console.log('Swap reversed: No match found.');
                    resolve(); // Resolve the promise after the animation and content swap
                }, ANIMATION_DURATION); // Match animation duration
            });
        }

        /**
         * Handles the sequence of clearing matches, activating special emojis,
         * applying gravity, and refilling the board, looping if chain reactions occur.
         */
        async function processBoard(initialSwapCells = null) {
            isProcessingBoard = true; // Set flag to prevent new swaps during processing

            let activityOccurred = true;
            let comboCount = 0;

            while (activityOccurred) {
                activityOccurred = false; // Reset for this loop iteration

                // 1. Handle special emoji activations from the initial swap (if any)
                let activatedCells = new Set(); // Cells affected by special emoji activations
                if (initialSwapCells && initialSwapCells.length === 2) {
                    const [cell1, cell2] = initialSwapCells;
                    const r1 = parseInt(cell1.dataset.row);
                    const c1 = parseInt(cell1.dataset.col);
                    const r2 = parseInt(cell2.dataset.row);
                    const c2 = parseInt(cell2.dataset.col);

                    const emoji1 = gameBoard[r1][c1];
                    const emoji2 = gameBoard[r2][c2];

                    // Combination: Color Bomb + Base Emoji
                    if ((emoji1 === COLOR_BOMB_EMOJI && BASE_EMOJIS.includes(emoji2)) ||
                        (emoji2 === COLOR_BOMB_EMOJI && BASE_EMOJIS.includes(emoji1))) {
                        const colorBombR = emoji1 === COLOR_BOMB_EMOJI ? r1 : r2;
                        const colorBombC = emoji1 === COLOR_BOMB_EMOJI ? c1 : c2;
                        const targetEmoji = emoji1 === COLOR_BOMB_EMOJI ? emoji2 : emoji1;
                        activateSpecialEmoji(colorBombR, colorBombC, COLOR_BOMB_EMOJI, targetEmoji).forEach(coord => activatedCells.add(coord));
                        gameBoard[colorBombR][colorBombC] = ''; // Clear the color bomb itself
                        getCellElement(colorBombR, colorBombC).classList.add('clearing'); // Animate its disappearance
                        activityOccurred = true;
                    }
                    // Combination: Two special emojis (Striped, Wrapped, Color Bomb)
                    else if ((emoji1 === STRIPED_EMOJI || emoji1 === WRAPPED_EMOJI || emoji1 === COLOR_BOMB_EMOJI) &&
                             (emoji2 === STRIPED_EMOJI || emoji2 === WRAPPED_EMOJI || emoji2 === COLOR_BOMB_EMOJI)) {
                        // For now, simple individual activation. Complex combinations (e.g., striped+wrapped) will be added later.
                        activateSpecialEmoji(r1, c1, emoji1).forEach(coord => activatedCells.add(coord));
                        activateSpecialEmoji(r2, c2, emoji2).forEach(coord => activatedCells.add(coord));
                        gameBoard[r1][c1] = ''; gameBoard[r2][c2] = ''; // Clear both special emojis
                        getCellElement(r1, c1).classList.add('clearing');
                        getCellElement(r2, c2).classList.add('clearing');
                        activityOccurred = true;
                    }
                }

                // Apply effects of activated special emojis (including those from combinations)
                if (activatedCells.size > 0) {
                    activityOccurred = true;
                    activatedCells.forEach(coord => {
                        const [r, c] = coord.split(',').map(Number);
                        if (gameBoard[r][c] !== '') { // Don't try to clear already cleared cells
                            gameBoard[r][c] = ''; // Clear affected cells
                            const cellElement = getCellElement(r, c);
                            if (cellElement) {
                                cellElement.classList.add('clearing');
                                setTimeout(() => {
                                    cellElement.textContent = '';
                                    cellElement.classList.remove('clearing');
                                }, ANIMATION_DURATION);
                            }
                            score += 10;
                        }
                    });
                    scoreElement.textContent = score;
                    await new Promise(resolve => setTimeout(resolve, ANIMATION_DURATION)); // Wait for special activation clearing animation
                }

                // 2. Check for and clear regular matches, and create new special emojis from cascades
                const { cellsToClear, specialCreations } = getMatchesOnBoard();
                console.log("Cells to clear after getMatchesOnBoard:", [...cellsToClear]);
                console.log("Special creations after getMatchesOnBoard:", specialCreations);


                if (cellsToClear.size > 0 || specialCreations.length > 0) {
                    activityOccurred = true;
                    comboCount++; // Increment combo count for each successful clear cycle

                    // Display combo text
                    if (comboCount === 2) showComboText("Nice!");
                    else if (comboCount === 3) showComboText("Great!");
                    else if (comboCount === 4) showComboText("Awesome!");
                    else if (comboCount >= 5) showComboText("Unbelievable!");

                    // Clear matched emojis visually and in gameBoard
                    cellsToClear.forEach(coord => {
                        const [r, c] = coord.split(',').map(Number);
                        const cellElement = getCellElement(r, c);
                        if (cellElement) {
                            cellElement.classList.add('clearing');
                            setTimeout(() => {
                                cellElement.textContent = '';
                                cellElement.classList.remove('clearing');
                            }, ANIMATION_DURATION);
                        }
                        gameBoard[r][c] = '';
                        score += 10;
                    });
                    scoreElement.textContent = score;

                    // Create special emojis after clearing
                    specialCreations.forEach(creation => {
                        const { row, col, type } = creation;
                        gameBoard[row][col] = type; // Update gameBoard with special emoji
                        const cellElement = getCellElement(row, col);
                        if (cellElement) {
                            cellElement.textContent = type; // Display special emoji
                            // Optional: Add a subtle animation for special emoji creation
                        }
                        console.log(`Special emoji created: ${type} at ${row},${col}`);
                    });

                    await new Promise(resolve => setTimeout(resolve, ANIMATION_DURATION)); // Wait for clearing/creation animation
                }

                // If any activity occurred (clearing or special activation/creation), apply gravity and refill
                if (activityOccurred) {
                    applyGravity();
                    await new Promise(resolve => setTimeout(resolve, ANIMATION_DURATION)); // Wait for falling animation
                    fillEmptySpaces();
                    await new Promise(resolve => setTimeout(resolve, ANIMATION_DURATION)); // Wait for new emojis to appear
                    // The loop will then re-check for new matches created by gravity/refill
                }
            }
            isProcessingBoard = false; // Reset flag when board is stable
            console.log('Board processing complete.');

            // After all processing, check game status
            checkGameStatus();
        }


        /**
         * Swaps the emojis between two given cell elements, both visually and in the gameBoard array, with animation.
         * After the animation, it checks for matches. If no matches, the swap is reversed.
         * @param {HTMLElement} cell1 The first cell element.
         * @param {HTMLElement} cell2 The second cell element.
         */
        function swapEmojis(cell1, cell2) {
            isSwapping = true; // Set flag to prevent further clicks
            playSound(220, 0.05); // Play swap sound

            const row1 = parseInt(cell1.dataset.row);
            const col1 = parseInt(cell1.dataset.col);
            const row2 = parseInt(cell2.dataset.row);
            const col2 = parseInt(cell2.dataset.col);

            // Calculate translation values for animation
            const deltaX1 = (col2 - col1) * CELL_SIZE;
            const deltaY1 = (row2 - row1) * CELL_SIZE;
            const deltaX2 = (col1 - col2) * CELL_SIZE; // Opposite direction for cell2
            const deltaY2 = (row1 - row2) * CELL_SIZE; // Opposite direction for cell2

            // Apply transform for animation
            cell1.style.transform = `translate(${deltaX1}px, ${deltaY1}px)`;
            cell2.style.transform = `translate(${deltaX2}px, ${deltaY2}px)`;

            // After the animation, swap content and reset transform
            setTimeout(async () => {
                // Swap emojis visually (textContent)
                const tempEmoji = cell1.textContent;
                cell1.textContent = cell2.textContent;
                cell2.textContent = tempEmoji;

                // Reset transform to original position
                cell1.style.transform = '';
                cell2.style.transform = '';

                // Swap emojis in the gameBoard array
                const tempGameBoardEmoji = gameBoard[row1][col1];
                gameBoard[row1][col1] = gameBoard[row2][col2];
                gameBoard[row2][col2] = tempGameBoardEmoji;

                isSwapping = false; // Reset flag after visual swap

                // Check if the swap resulted in any immediate matches or special activations
                const { cellsToClear, specialCreations } = getMatchesOnBoard();
                let initialActivity = cellsToClear.size > 0 || specialCreations.length > 0;

                // Also check for special candy combinations (e.g., Color Bomb + Base Emoji)
                const emoji1AfterSwap = gameBoard[row1][col1];
                const emoji2AfterSwap = gameBoard[row2][col2];
                const isColorBombSwap = (emoji1AfterSwap === COLOR_BOMB_EMOJI && BASE_EMOJIS.includes(emoji2AfterSwap)) ||
                                        (emoji2AfterSwap === COLOR_BOMB_EMOJI && BASE_EMOJIS.includes(emoji1AfterSwap));
                const areBothSpecial = (emoji1AfterSwap === STRIPED_EMOJI || emoji1AfterSwap === WRAPPED_EMOJI || emoji1AfterSwap === COLOR_BOMB_EMOJI) &&
                                       (emoji2AfterSwap === STRIPED_EMOJI || emoji2AfterSwap === WRAPPED_EMOJI || emoji2AfterSwap === COLOR_BOMB_EMOJI);


                if (!initialActivity && !isColorBombSwap && !areBothSpecial) {
                    // If no matches and no special-special swap, reverse the swap
                    await reverseSwap(cell1, cell2); // Await the reverse animation
                    moves--; // Decrement moves if swap was invalid and reversed
                    movesElement.textContent = moves;
                    checkGameStatus(); // Check game status after a failed swap
                } else {
                    // If matches were found, or it was a special-special swap, proceed with board processing
                    await processBoard([cell1, cell2]); // Pass swapped cells for special combo handling
                }

            }, ANIMATION_DURATION); // This timeout should match the CSS transition duration
        }

        /**
         * Handles the click event on an emoji cell.
         * Manages selecting the first cell and attempting to swap with a second adjacent cell.
         * @param {Event} event The click event object.
         */
        function handleCellClick(event) {
            // Prevent clicks if a swap animation or board processing is in progress
            if (isSwapping || isProcessingBoard) {
                return;
            }

            const clickedCell = event.target;
            const clickedRow = parseInt(clickedCell.dataset.row);
            const clickedCol = parseInt(clickedCell.dataset.col);

            // If no cell is currently selected, select this one
            if (!selectedCell) {
                selectedCell = clickedCell;
                selectedCell.classList.add('selected'); // Add visual highlight
            } else {
                // A cell is already selected, now check if the clicked cell is adjacent
                const selectedRow = parseInt(selectedCell.dataset.row);
                const selectedCol = parseInt(selectedCell.dataset.col);

                // Check if the clicked cell is adjacent (horizontally or vertically)
                const isAdjacent =
                    (Math.abs(clickedRow - selectedRow) === 1 && clickedCol === selectedCol) || // Vertical adjacency
                    (Math.abs(clickedCol - selectedCol) === 1 && clickedRow === selectedRow);   // Horizontal adjacency

                if (isAdjacent) {
                    // If adjacent, perform the swap
                    swapEmojis(selectedCell, clickedCell);
                    // After a swap, clear the selection
                    selectedCell.classList.remove('selected');
                    selectedCell = null;
                    moves++; // Increment moves after a valid swap
                    movesElement.textContent = moves;
                } else {
                    // If not adjacent, deselect the previous cell and select the new one
                    selectedCell.classList.remove('selected');
                    selectedCell = clickedCell;
                    selectedCell.classList.add('selected');
                }
            }
        }

        /**
         * Checks the current game status (win/lose).
         */
        function checkGameStatus() {
            const currentLevel = levels[currentLevelIndex];
            if (score >= currentLevel.targetScore) {
                playSound(1000, 0.5, 'square'); // Win sound
                showMessage("Level Complete!", `You reached the target score of ${currentLevel.targetScore}!`, "Next Level");
                messageButton.onclick = nextLevel;
            } else if (moves >= currentLevel.maxMoves) {
                playSound(150, 0.5, 'sawtooth'); // Lose sound
                showMessage("Game Over!", `You ran out of moves. Try again!`, "Try Again");
                messageButton.onclick = resetGame;
            }
        }

        /**
         * Displays the message box.
         * @param {string} title The title of the message.
         * @param {string} text The main text content.
         * @param {string} buttonText The text for the button.
         */
        function showMessage(title, text, buttonText) {
            messageTitle.textContent = title;
            messageText.textContent = text;
            messageButton.textContent = buttonText;
            messageBoxOverlay.classList.remove('hidden');
        }

        /**
         * Hides the message box.
         */
        function hideMessage() {
            messageBoxOverlay.classList.add('hidden');
        }

        /**
         * Resets the game to the current level.
         */
        function resetGame() {
            hideMessage();
            score = 0;
            moves = 0;
            initializeBoard();
            updateGameInfo();
        }

        /**
         * Advances to the next level or restarts if all levels are complete.
         */
        function nextLevel() {
            hideMessage();
            currentLevelIndex++;
            if (currentLevelIndex < levels.length) {
                score = 0; // Reset score for new level
                moves = 0; // Reset moves for new level
                initializeBoard();
                updateGameInfo();
            } else {
                // All levels completed
                showMessage("Congratulations!", "You've completed all levels!", "Play Again from Level 1");
                currentLevelIndex = 0; // Reset to first level for replay
                messageButton.onclick = resetGame;
            }
        }

        /**
         * Updates the score, moves, and level display on the UI.
         */
        function updateGameInfo() {
            levelElement.textContent = currentLevelIndex + 1;
            scoreElement.textContent = score;
            targetScoreElement.textContent = levels[currentLevelIndex].targetScore;
            movesElement.textContent = levels[currentLevelIndex].maxMoves - moves; // Display remaining moves
        }

        /**
         * Initializes the game board by creating and populating cells with random emojis.
         * Ensures no initial matches are present on the board.
         * Attaches click event listeners to each cell.
         */
        function initializeBoard() {
            // Set up CSS grid properties dynamically based on board dimensions
            gameBoardElement.style.gridTemplateColumns = `repeat(${BOARD_COLS}, ${CELL_SIZE}px)`;
            gameBoardElement.style.gridTemplateRows = `repeat(${BOARD_ROWS}, ${CELL_SIZE}px)`;

            // Clear any existing cells
            gameBoardElement.innerHTML = '';
            gameBoard = []; // Reset the game board array

            for (let r = 0; r < BOARD_ROWS; r++) {
                gameBoard[r] = []; // Initialize row array
                for (let c = 0; c < BOARD_COLS; c++) {
                    let randomEmoji;
                    let isMatch;
                    do {
                        isMatch = false;
                        randomEmoji = getRandomBaseEmoji(); // Use the new function

                        // Check for horizontal match with previous two emojis
                        if (c >= 2 && gameBoard[r][c - 1] === randomEmoji && gameBoard[r][c - 2] === randomEmoji) {
                            isMatch = true;
                        }
                        // Check for vertical match with previous two emojis
                        if (r >= 2 && gameBoard[r - 1][c] === randomEmoji && gameBoard[r - 2][c] === randomEmoji) {
                            isMatch = true;
                        }
                    } while (isMatch); // Keep trying until no initial match is formed

                    gameBoard[r][c] = randomEmoji; // Store emoji in game state

                    // Create the cell element
                    const cell = document.createElement('div');
                    cell.classList.add('emoji-cell', 'rounded-lg'); // Add Tailwind rounded corners
                    cell.dataset.row = r; // Store row index
                    cell.dataset.col = c; // Store column index
                    cell.textContent = randomEmoji; // Display the emoji

                    // Add click event listener to each cell
                    cell.addEventListener('click', handleCellClick);

                    // Append cell to the game board
                    gameBoardElement.appendChild(cell);
                }
            }

            updateGameInfo(); // Update UI with current level info
            console.log('Board initialized with no initial matches:', gameBoard);
        }

        // Call initializeBoard when the window loads
        window.onload = initializeBoard;

    </script>
</body>
</html>
